LTS Calendar database schema

TODO:

* Users can change their password
* Admin can mark booking as paid
* Show own bookings also in calendar
* Don't remove courts permanently
* Send email of bookings

DONE:

* Finnish date format
* Verify argument types instead of assuming and crashing
* Can't book to the past
* Pretty booking table
* Server-side booking time validation
* myHandler's targets should return an error and HTTP statuscode.
  Then myHandler could do the logging and responding with the error
* Redirect to login page from non-public URLs
* Server: Can't book if every user setting isn't filled
* Admin can see who booked anything in calendar
* Calendar is reloaded whenever the page changes back to /calendar
* Own Bookings page:
  * Ability to cancel booking 8 hours before begin
* Title instead of username in bookings
* Admin can book for any name
* TLS
* Admin can cancel bookings any time
* Optimized deployment

db.users.createIndex({username: 1}, {unique: true});
db.courts.createIndex({name: 1}, {unique: true});
db.bookings.createIndex({begin: 1, end: 1});

users:
{
	"username": "johnny",
	"name": "John Smith",
	"email": "john.smith@example.org",
	"password" "pw_hash",
	"created_at": <timestamp>,
	"street_address": "Some Road 13",
	"postal_code": "12345",
	"phone_number": "0501234567",
	"lts_member": <boolean>,
	"level": <admin|user>
}

courts:
{
	"name": "Kimpinen #1",
	"created_at": <timestamp>,
	"hours": [
		{
			"begin": "08:00",
			"end": "21:00"
		},
		...
		{
			"begin": "10:00",
			"end": "18:00"
		}
	]
}

bookings:
{
	"_id": <booking_id>,
	"user_id": <users_id>,
	"court_id": <courts_id>,
	"created_at": <timestamp>,
	"begin": <timestamp>,
	"end": <timestamp>
}


bookings query:

params:
- date_begin: "2017-05-29"
- date_end: "2017-05-30" (optional, admin-only)
- user: "johnny" (optional, admin-only)

response:
[
	<booking>
]